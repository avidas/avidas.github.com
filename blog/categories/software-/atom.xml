<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Software, | Avi Das]]></title>
  <link href="http://avidas.github.com/blog/categories/software-/atom.xml" rel="self"/>
  <link href="http://avidas.github.com/"/>
  <updated>2019-02-18T10:59:01-05:00</updated>
  <id>http://avidas.github.com/</id>
  <author>
    <name><![CDATA[Avi (Ananya Das)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Guide to finding a technical cofounder]]></title>
    <link href="http://avidas.github.com/blog/2015/08/21/guide-to-finding-a-technical-cofounder/"/>
    <updated>2015-08-21T23:04:00-04:00</updated>
    <id>http://avidas.github.com/blog/2015/08/21/guide-to-finding-a-technical-cofounder</id>
    <content type="html"><![CDATA[<p>This has been happening at various meetups/hackathons/startup events sufficiently enough to warrant a blogpost. The situation is generally a variant of this, someone has an idea they are really convinced is the next big thing, the only thing stopping that from happening is making an app/website which requires a technical cofounder. The person with the idea is not at a position to afford the costs of hiring a full time/part time developer, so an equity sharing situation makes sense. Hackathons and tech meetups are where developers hang out, so approaching them there seem to be a good idea to find that cofounder.</p>

<p>There are a few problems to approaches like this. Software people who go to events like this gets pitched a fair amount, sometimes repeatedly on the same ideas. Also, we can be a rather cynical bunch, often as result of the kind of work that we do. This can result you not finding that engineer/hacker to build your app during a hackathon. Or they might do so during the hackathon, but simply drop off after.</p>

<p>It can get discouraging, specially if you are convinced about the idea and new to such events. Personally, I like idea people, specially because they bring in ideas from domains and problem spaces I would have no exposure to otherwise. Moreover, I also believe that cross-pollination of people from different groups is healthy and more products coming into the world is a good thing. Therefore, I would rather like to jot down some helpful tips which can maximize your chances of finding a technical cofounder next time you are looking for one.</p>

<ol>
<li><p><strong>Understand what motivates engineers</strong>: It's important to understand what motivates engineers beyond just financial opportunity. If such an opportunity exists, you may be in pretty decent shape already and should really drill down on your exact plans on how the app would make money in the future. If you are less sure, there are still options. Can you prove that the app would have a broad user base? A great way to do this would be to prove that you have tried unscalable ways doing this already, be it door-to-door, personal know how, competitors etc. Most ideas can be validated using non-technical approaches. Knowing your problem space well will not only help you to build a business but also lend credibility when you are looking for a cofounder. Another thing that attracts is interesting technical problems or cutting-edge tech, so if your app involves either, it would be a positive. Good technical co founders can be extremely self-motivated once they realize that they have a problem is really worth spending time on.</p></li>
<li><p><strong>Manage expectations</strong>: It is best to present the idea and the opportunity and not expect immediate commitment. Generally people are busy, but if you have done your homework and can present the problem well, there is always a good chance. Not all engineers want the same thing, and lot are perfectly happy working where they are. If you do not have a proven user base or revenue plan yet, it does involve a certain risk-taking to get on that journey. As someone who wants to be a founder, you should seek technical co-founders with the same risk appetite as you.</p></li>
</ol>


<!-- more -->


<ol>
<li><p><strong>Don't get discouraged</strong>: This may sound like packaged advice, but most likely, if someone says no, it is far more likely that they are rejecting the idea and not rejecting you. It suffices to be polite and ask for their reasoning. Most people are nice enough to talk about why they are not willing to work on that idea and you might get valuable feedback.</p></li>
<li><p><strong>Understand the software development cycle</strong>: The more you understand technology and what goes into building software, the better suited you are to recruit engineers. Timelines/delivery/delays, features and priorities, tradeoffs and optimizations are broad concepts that are just as important as picking languages, tools and platforms. Unsexy things such as debugging a database inconsistency could take up a lot more time than building the next cool feature. Prototyping an app during a hackathon is fun, the real work is afterwards and your story and contribution needs to be compelling enough for people to continue working.</p></li>
<li><p><strong>Use existing networks</strong>: Leverage existing networks such as college alumni and people you know might work better than approaching random hackers at events. If you have worked on other projects before, or are connected via friends to developers who are working on related projects, you would have a better chance of finding technical cofounders.</p></li>
</ol>


<p>Boom times in the valley/economy means that building an startup/company is an attractive prospect, and gives software engineers options on the table. Despite that, armed with a compelling idea, good buisness acumen, and clear idea of your contribution to the project, you have very good chance of recruiting engineers to help found your dream company. Good luck on the journey.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Browserify improves Client-side Development]]></title>
    <link href="http://avidas.github.com/blog/2015/07/16/how-browserify-improves-client-side-development/"/>
    <updated>2015-07-16T14:41:00-04:00</updated>
    <id>http://avidas.github.com/blog/2015/07/16/how-browserify-improves-client-side-development</id>
    <content type="html"><![CDATA[<h4>For a more modular, maintainable Frontend</h4>

<p>As Single Page Applications gain in popularity, the size of front end codebases keeps growing rapidly. For keeping these codebases maintainable, modularity becomes a priority. The easier it is to modularize code, the more incentives developers will have for doing so. With the ease of modularity with CommonJS, npm has seen explosive growth of packages published which has helped the Node ecosystem greatly. Browserify brings that ease to client side development leveraging the CommonJS module system. When used with build tools such as Grunt or Gulp, you can write modular client side code just like you would write your server side Node code, and Browserify takes care of the bundling for you. There is much less excuse these days to make everything global and attach to the window object!</p>

<h4>Leveraging npm modules</h4>

<p><img class="left" src="/images/Modulecounts.jpg" width="800" height="670" title="Package Manager Traction" alt="Package Manager Traction"></p>

<p>Looking at the graph above is a big selling point when trying to evaluate the value Browserify can bring to your client side workflow. The graph is a comparison of the rate at which packages are getting published in different package managers Bower, PyPI, RubyGems. npm leads the pack easily. Recently, jQuery registry stopped accepting new plugins, with <a href="http://blog.npmjs.org/post/111475741445/publishing-your-jquery-plugin-to-npm-the-quick">new packages being published on npm</a>. Cordova recently announced the same change, moving plugins to npm. npm is now hosting much broader range of modules than only server-side Node.js modules and Browserify can help you leverage these modules on the front-end. The flipside of this as a module publisher is that publishing modules on npm now gives you access to a much broader audience since people might use the module on the browser, custom hardware etc.</p>

<h4>How it works</h4>

<p>In the CommonJS syntax, the "exports" object is the public API of a module and "require" can be used to include a module in your javascript file. Since browsers do not have require available, Browserify traverses the <a href="https://github.com/substack/browserify-handbook#how-browserify-works">dependency trees</a> of all the required modules, and bundles the dependencies into one self contained file that you can just include with a script tag on the browser. Browserify is aware of package.json and the order in which node_modules are resolved. Moreover, it supports built in Node modules e.g. path and gloabls e.g. Buffer so you have access of those in the client side as well.</p>

<h4>Transforms</h4>

<p>Core Browserify only bundles modules written in the CommonJS syntax, adhering to the single responsibility principle. However, there are other ways of modularizing client side code, AMD and Global Variables being the two usual ones. Instead of handling every possibly of modules, Browserify exposes a Transforms API so that a plugin can be built which can preprocess a file into Javascript in CommonJS syntax which Browserify can then consume. This means that you can write modular code just like your node codebases regardless of what module system your dependencies may adhere to. There are also lot of people writing in languages that compile into Javascript, such as CoffeeScript or TypeScript. To handle this, there are transforms available for AMD (deamdify), Bower modules (debowerify), globals (deglobalify), coffeescript(coffeeify), harmony (es6ify) etc. A simple search of Browserify on Github or npm brings up thousands of modules and attests to the <a href="https://github.com/substack/node-browserify/wiki/list-of-transforms">ecosystem around Browserify</a>. Delegating to transforms helps to keep the footprint of Browserify smaller, while makes it more extensible.</p>

<!-- more -->


<h4>Using with Build Tools</h4>

<p>Software is great when it just works and you do not have tinker with it all the time. Grunt/Gulp are great for this kind of configure once, build whenever workflow. Browserify is available as a command line tool primarily, but has Grunt and Gulp plugins which can be used to easily integrate Browserify into your build. There is also watchify, which can reduce build time by monitoring source files and incrementally rebuilding the front end bundle on the fly. For large projects, this is really useful to keep the build times small.</p>

<h4>Alternatives</h4>

<p>There are always alternatives available in the JavaScript world, and Webpack, RequireJS and Component being some of the major ones. RequireJS has been around for longer and primarily supports the AMD specification, but has support for CommonJS too. Webpack tends to do better with static assets that your client side requires and tries to cover a broader issue of bundling all static assets. With picking any tool, it's good to be aware of the alternatives, the problem they were designed to solve, and benefits and drawbacks of each. It makes for <a href="https://gist.github.com/substack/68f8d502be42d5cd4942">quite interesting debate</a> at times as well.</p>

<h4>Resources</h4>

<p>Browserify has really good documentation and the <a href="https://github.com/substack/browserify-handbook">browserify handbook</a> is a great resource for an extensive runthrough. For getting started, the nodeschool module called <a href="https://github.com/substack/browserify-adventure">browserify-adventure</a> is very handy.</p>

<h4>Conclusion</h4>

<p>The browser community is unlikely to adopt a module system anytime soon. Harmony/ES6 includes a module definition but it will take time before it gets adopted by all the browsers. Moreover, there have been <a href="https://esdiscuss.org/topic/es6-modules-sorry">resistance from some notable developers</a>.</p>

<p>Browserify offers a great way to abstract away that issue. With access to a vast amount of modules, there is much less of a need for reinventing the wheel on the client side, and fewer script tags thrown around everywhere. Client side software development is evolving fast, and Browserify has made significant progress to minimize some of that complexity.</p>

<p>If you are using browserify/webpack in production, I would love to know the tradeoffs/issues you have ran into. Comments/feedback here or <a href="mailto:avi@aviadas.com">contact</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verifying X509 Certificate Chain of Trust in Python]]></title>
    <link href="http://avidas.github.com/blog/2015/06/18/verifying-x509-certificate-chain-of-trust-in-python/"/>
    <updated>2015-06-18T17:07:00-04:00</updated>
    <id>http://avidas.github.com/blog/2015/06/18/verifying-x509-certificate-chain-of-trust-in-python</id>
    <content type="html"><![CDATA[<p>Executing network spoofing and man in the middle attacks have become easier than ever. This is more of an issue if a client has an open server for you to send push notifications, since the open port can be detected by methods such as port scanning. As such, it is important to sign data, and ship the signature and metadata about verifying the data against the signature along with the data itself. This provides a way for the client to verify that the data received is unaltered, from the correct sender and indented for the correct recipient. Python's pyopenssl has a handy method called <a href="http://pyopenssl.readthedocs.org/en/latest/api/crypto.html?highlight=verify#OpenSSL.crypto.verify">verify</a> for checking the authenticity of data.</p>

<p><code>python
OpenSSL.crypto.verify(certificate, signature, data, digest)
</code></p>

<p>The problem then becomes how to provide the certificate while retaining the flexibility necessary to update the certificate without clients needing to modify their certificate stores every time. Providing a url that can be used to download the cert provides that but leaves the door open for the same kind of attacks.</p>

<p>Therefore, clients will need to ensure that the downloaded certificate is trustworthy before using it to verify the authenticity of a message. The openssl module on the terminal has a <a href="https://www.openssl.org/docs/apps/verify.html">verify method</a> that can be used to verify the certificate against a chain of trusted certificates, going all the way back to the root CA. The builtin ssl module has create_default_context(), which can build a certificate chain while creating a new SSLContext. However, it does not expose that functionality for adhoc post processing when you are not opening new connections.</p>

<p>pyopenssl provides some very handy abstractions for exactly this purpose:</p>

<ul>
<li><p><a href="http://pyopenssl.readthedocs.org/en/latest/api/crypto.html#x509store-objects">X509Store</a>: The chain of certificates you have chosen to trust going back to root Certificate Authority</p></li>
<li><p><a href="http://pyopenssl.readthedocs.org/en/latest/api/crypto.html#x509storecontext-objects">X509StoreContext</a> - Takes in a X509Store and a new certificate which you can now validate against your store by calling verify_certificate. It raises exceptions if the intermediate or root CA is missing in the chain or the certificate is invalid.</p></li>
</ul>


<p> The full example of verifying a downloaded certificate against a trust chain is given below</p>

<p>```python
import requests
from OpenSSL import crypto</p>

<p>def _verify_certificate_chain(cert_url, trusted_certs):</p>

<pre><code># Download the certificate from the url and load the certificate
cert_str = requests.get(cert_url)
certificate = crypto.load_certificate(crypto.FILETYPE_PEM, str(cert_str.text))

#Create a certificate store and add your trusted certs
try:
    store = crypto.X509Store()

    # Assuming the certificates are in PEM format in a trusted_certs list
    for _cert in trusted_certs:
        store.add_cert(_cert)

    # Create a certificate context using the store and the downloaded certificate
    store_ctx = crypto.X509StoreContext(store, certificate)

    # Verify the certificate, returns None if it can validate the certificate
    store_ctx.verify_certificate()

    return True

except Exception as e:
    print(e)
    return False
</code></pre>

<p>```</p>

<p>Using this can be really useful for client libaries where you cannot rely on the system to provide the certificates, so you can ship your trust chain along with the library. There are also other useful abstractions in the pyopenssl library for some useful checks against the certificate. get_subject() provides information about the certificate such as common name, has_expired() which checks if the certificate is within valid time range and other features such as blacklisting potentially compromised certificates are possible. Thus pyopenssl is really handy when you need ssl abstractions beyond the standard library while not needing to execute the openssl shell calls via a subprocess.</p>
]]></content>
  </entry>
  
</feed>
