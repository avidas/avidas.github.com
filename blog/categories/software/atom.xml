<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Software | Avi Das]]></title>
  <link href="http://avidas.github.com/blog/categories/software/atom.xml" rel="self"/>
  <link href="http://avidas.github.com/"/>
  <updated>2020-04-12T20:47:30-04:00</updated>
  <id>http://avidas.github.com/</id>
  <author>
    <name><![CDATA[Avi (Ananya Das)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Amsterdam 2019: Takeaway]]></title>
    <link href="http://avidas.github.com/blog/2019/04/14/react-amsterdam-2019-takeaways/"/>
    <updated>2019-04-14T11:16:00-04:00</updated>
    <id>http://avidas.github.com/blog/2019/04/14/react-amsterdam-2019-takeaways</id>
    <content type="html"><![CDATA[<ul>
<li>The case of GraphQL (Peggy Rayzis)

<ul>
<li>Productivity boost across teams</li>
<li>Smaller payloads</li>
<li>Fewer client/server round trips</li>
<li>Preventing over fetching</li>
</ul>
</li>
<li>Great Developer Experience (Peggy Rayzis)

<ul>
<li>Unobtrusive, out of the way e.g. Prettier</li>
<li>Predictable and intuitive, e.g. declarative React paradigm</li>
<li>Instant Feedback Loop e.g. VSCode/TS</li>
</ul>
</li>
<li>Design Systems (Mark Dalgleish &amp; Andrey Okonetchnikov)

<ul>
<li>Universal Language > Technology</li>
<li>Set of design related rules as system of instructions that can be reused across products</li>
<li>Shared language between designers and developers enforced by tooling</li>
<li>Design powered development tools</li>
<li>Developer workflows as productive as designers</li>
<li>UI components and pattern libraries can provide this intermediate abstraction and be a common language for both designers and developers.</li>
</ul>
</li>
<li>Micro Frontends (Max Gallo)

<ul>
<li>Autonomy/Responsibility with Teams Innovation</li>
</ul>
</li>
<li>Better you understand the abstraction, better you are at using it (Kent C Dodds)</li>
<li>Write code that is resilient to future change (Max Stoiber)</li>
<li>Use existing solutions for tech problems if you donâ€™t understand deeply (Bias towards conservative choices)</li>
<li>Be open about roadmap to learn about users priorities</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Frame code reviews as gift exchanges]]></title>
    <link href="http://avidas.github.com/blog/2019/03/16/pull-requests-as-gift-exchange/"/>
    <updated>2019-03-16T15:04:00-04:00</updated>
    <id>http://avidas.github.com/blog/2019/03/16/pull-requests-as-gift-exchange</id>
    <content type="html"><![CDATA[<p>The best metaphor I have found for thinking about code reviews is a gift exchange. The terms pull request and code reviews will be used interchangeably in this post.</p>

<p>The balance of writing code vs everything else that is necessary to be a successful member of a software team is one of the key challenges of our job.</p>

<p>Code reviews are an interesting mix. You have to understand someone else's point of view, their journey through solving a problem in form of code. Or you have to face up to what everyone else thinks about code that you worked hard to write. Those reviews stand in your way of getting your code up to users and getting the emotional payoff from releasing something. The engagement or catharsis from building software is not an available reward when you are in code review mode.</p>

<p>Moreover, a code review must take into consideration not just the code, but the project, team and the company into consideration.</p>

<p>These qualities make code review a great opportunity to practice interpersonal skills alongside your programming skills. The best engineers I have worked with take code reviews and responding to feedback on their own pull requests very seriously. Specific strategies that engineers use are different. Some review pull requests first time in the day, others end of the day or anything in between.</p>

<p>Framing is a powerful technique we can use when summoning the energy to do code review everyday. It would be to see every request for a code review or feedback you receive on code review as a gift. Someone values your intelligence enough to ask for your review or taking their valuable time to give you feedback that can only improve you as an engineer. Everyday, you receive these gifts. But you can also offer them to others, which in itself is a meaningful and satisfying act.</p>

<p>Viewing pull requests this way makes them less of a transaction, and illustrates code reviews as a win-win game. So next time you are opening up a pull request, think how you can make it easier for someone else to review. Can you link to the ticket, provide a screenshot/gif, added sufficient comments and followed good coding practices? Have you considered breaking your change into smaller chunks? Can you sit down with a reviewer and go over the changes in code?</p>

<p>Let's make it easier for someone else to offer us this gift.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thoughts on button push driven development]]></title>
    <link href="http://avidas.github.com/blog/2019/02/24/on-button-push-driven-development/"/>
    <updated>2019-02-24T09:19:00-05:00</updated>
    <id>http://avidas.github.com/blog/2019/02/24/on-button-push-driven-development</id>
    <content type="html"><![CDATA[<p>I was in a conversation the other day when someone mentioned</p>

<p><em>"We may only be a couple Moore's Law iterations away from all software built by pushing buttons and WYSIWYG editors."</em></p>

<p>This made me think of the software that we write today and the direction software is going. It also made me think of why I got into software and am still in this profession.</p>

<p>Lately, I have been very curious about voice as a computing platform and what that will do for applications we use in future. Thankfully, as software engineers, we don't have to hypothesize. We can build it.</p>

<p>Digging into Alexa skills development has been interesting. While the technical documentation and development for Alexa is quite good, I felt a fair amount of internal resistance during the project. The potential of this new computing platform and the possibilities it will bring kept me going.</p>

<p>The building blocks of working with Alexa are intents, utterances and lambda functions. After a series of thirty or so steps of wiring up buttons, copying and moving templates around, setting up attributes gives you a working voice enabled app, upload zip files, deploy it and submit for app review in the Alexa app store.</p>

<p>Why did I feel the resistance? Any new tool or language will bring an initial set of frustration before we achieve a minimal level of proficiency. But Alexa development felt like using a software program rather than programming. It felt challenging the way gruntwork feels challenging and as opposed to intellectually stimulating. It also felt opposite to when I have felt the most joy during programming. When I had a strong grasp of the vocabulary of the language and the meta-language (libraries, development environment,runtime, etc), leaving room for higher level product/architectural decisions where most things are a tradeoff. This meant I had to do <em>very minimal context switching</em>. When writing an app for Alexa, it feels driven by context switching.</p>

<!-- more -->


<p>Continuous context switching has real penalties. In <a href="https://www.amazon.com/Deep-Work-Focused-Success-Distracted/dp/1455586692">Deep Work</a>, Cal Newport points out that the more time we spend effortlessly focusing on a difficult task, the happier we are. The ability to do deep work is one of the greatest joys of programming. So while using WISYWIG or code as configuration can lower barrier to entry for software development, they do take away the mindful aspects of programming.</p>

<p>That left me with the following thoughts.</p>

<ol>
<li>Democratizing building of software applications is the direction in which software should go. <em>Just like literacy, tools of creativity should not be limited to those who have the time to learn or funding to hire people to do it.</em> If information hoarding is one's only advantage, one is asking for disruption.</li>
<li><em>If solving problems is what gets you excited about programming, in the next decade you will want to think about focusing on areas more resistant to this change</em>. Infrastructure and tools development are more resistant to this change than application development, but there is less of it to be built compared to applications.</li>
<li><em>Programming is still a difficult thing to do. Building quality, lasting software is expensive for a business.</em> For a business, the ability to reduce this cost by using WISYWIG tools or code as configuration will always be appealing.</li>
<li>WISYWIGs encourages dependence on higher level tools which reduces the need to learn about the fundamentals and increases the risk when the tools themselves break.</li>
</ol>


<p>I hope this is a blogpost I get to laugh it in five years due to how much things have changed. But I do think this trend in software development has consequences as far as who will be interested in programming in the future and the intention people have when they get into programming.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core tenants of highly effective software teams]]></title>
    <link href="http://avidas.github.com/blog/2018/11/03/core-tenants-of-effective-software-teams/"/>
    <updated>2018-11-03T11:47:00-04:00</updated>
    <id>http://avidas.github.com/blog/2018/11/03/core-tenants-of-effective-software-teams</id>
    <content type="html"><![CDATA[<p><em>This blogpost is my thoughts only and does not necessarily represent the positions of current or past employers.</em></p>

<p>We don't build software in a vacuum. Software involves people. Beyond organizations of a handful of people, hierarchy is beneficial. We get teams, commonly with engineering manager/lead, product manager, designers and engineers. What becomes crucial for the software and the product delivered then is the effectiveness of the team. Throughout my career in the industry and being part of many teams in different circumstances, I have started noticing some key patterns that really drives standout results in teams.</p>

<ol>
<li><p><strong>Believing in a common cause</strong>: The single biggest observation is that when a team of people believe in a common mission, they produce outsized returns. The most effective teams I have worked in all had a strong belief that they was a reason for the work they were doing. This also aids inter team collaboration over inter team competition, with teams often investing in tooling that makes the whole team better.<br/><br/>Engineering leaders can play a key role here to frame a compelling mission for the team. Hiring for the right role also becomes super important as a highly motivated individual in a role can be 2-10x more effective than someone unmotivated with similar ability. Having a competitor or a common enemy is great since we are predisposed to bond over defending ourselves from common enemies.</p></li>
<li><p><strong>Psychological Safety</strong>: Google's <a href="https://www.nytimes.com/2016/02/28/magazine/what-google-learned-from-its-quest-to-build-the-perfect-team.html?_r=0">Project Aristotle</a> studied 180 teams over two years and came to the conclusion that psycological safety was the best signal for how effective a team is. How comfortable do people in the team feel to share vulnerability without fear of retribution? How comfortable do people feel asking questions without fear of asking something silly or share ideas without fear of being shut down without listening? Team's with high levels of psychological safety can have conflicts, but can deal with them in a mature way, being able to separate disagreement about ideas from disagreement with people.<br/><br/>For more senior engineers/technical leaders, this is crucially important since they are in a position to determine this culture for the team. Forming strong personal relationships with the team can be really valuable for fostering safety within the team. People like their leaders to be human, and admitting your own fallibility is a great way to form trust with team members.</p></li>
<li><p><strong>Diversity of Thought</strong>: Diversity is a word that is commonly heard in the tech industry, and for good reason. Having diversity of people is a proven way to achieving diversity of thought, which is just one of the reasons why we must invest in software communities of women and minorities. Inclusiveness is one of the key pillars of psychological safety in a team, building on from the last section. Moreover, when software is aimed at global audience, but the team is homogeneous, it is easy to be fooled that a wide audience will get their needs met.<br/><br/>Even teams of experienced contributors can fall prey to atrophy and decay, without fresh ideas so common in upstarts. A team of really excited newer developers may not realize that in balance lies the key to long term personal, team and product success. Diversity of experience in a team helps to avoid these common traps.<br/><br/>Finally, cross functional teams can be more effective than teams exclusively focusing on frontend/backend/mobile. Recognizing the individual contributor's interest in user experience/security/governance etc and enabling space for that one of the most enabling things an engineer leader can do.</p></li>
<li><p><strong>Growth and Ownership</strong>: It is immensely gratifying for people to feel that they are growing, and knowing that they are playing a role in the growth of others. When team members feel confident about the path in front of them can still have challenges, they are far less likely to be unmotivated and plateau. This is big for retention, since job changes frequently are a result of people feeling stuck and needing to make a change. It is costly to replace engineers, especially ones already trained and performing well in their role.<br/><br/>A key intrinsic motivator for many is the feeling of ownership. Being able to really sink their teeth into a hard problem and come up with something they are proud of. Teams where people really believed that they have strong ownership of the product also care more about the end users experience, resulting in a better product.<br/><br/>As engineering leadership, one of the best signals of good management is to have clarity in career ladders and promote the right people. A bias for people who make others around them better can be healthy. It is my experience that promotions should rarely come as a surprise to the individual or the team. Demonstrated investment in people as future leaders is also a major indication of a company's belief in their people, sending them to conferences, training and giving license for creativity.</p></li>
<li><p><strong>Work Environment</strong>: This is a controversial one, but I do believe that companies today have bought way too much into the open office movement. While a return to cubicles does not feel desirable, dedicated interruption free zones (both space and time) are essential for good software. A chaotic office environment can also mean chaos in your codebase.<br/><br/>Debates range whether standing desk or sitting is better, however many monitors are necessary. My belief here is that the team should be colocated but individuals should be empowered to find the best working situation for the track of work they are in. I have personally found that standing keeps me on my toes, making it great for lots of small tasks, whereas sitting is best for tasks that need deep thought.</p></li>
</ol>


<p><strong>When things fall apart</strong></p>

<p>We do not live in a perfect world. Recessions, unexpected downsizing, market competition and many other forces can impact access to resources which could result in ways in a group of people come in to work together and stop working together. Lot of us have all worked in a team where that magic of a great team existed, and the team achieved things together what could not be achieved by individuals. It is important for us to be thinking with intention and purpose and help each other build and find teams to discover that magic.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lower Degrees of Separation with End Users]]></title>
    <link href="http://avidas.github.com/blog/2018/05/09/degrees-of-separation-with-end-users/"/>
    <updated>2018-05-09T10:21:00-04:00</updated>
    <id>http://avidas.github.com/blog/2018/05/09/degrees-of-separation-with-end-users</id>
    <content type="html"><![CDATA[<p>When working in software, one way to look at our profession is to say that we take architecture docs or designs and make code out of it. After years in the industry, we are trusted to come up with the architecture docs and work with a team to deliver the software. This absolves ourselves of responsibility in a way since even if the product fails, at least our code and systems were great. Companies today, however, are starting to see the limitations of software engineers being removed from the product decision making process.</p>

<p>I think we should reframe the problem: it is rather our responsibility as software engineers to ask, how many degrees of separation does it exist between us and the end user? Ideally, the end user would be the person paying for our service, although this gets more complicated certainly by ad funded or venture funded software. The exercise could involve us asking, what would it take to reach 10 users of our software? Would we have to go through our product manager, who then talks to the account manager or product support? These are likely the folks currently dealing with customer calls when our software bresks and waiting for the Zendesk tickets to be picked from the queue.</p>

<p>Who we are "engineering" for is a question we need to frequently ask ourselves. We should strive to be in environments where we are aware of our degree of separation and look for ways to cut down that separation. Without that frame, we can only have vague ideas of what the code we write is leading to, and end of the day limits the impact we can have.</p>

<p>It should also not always be the product manager's job to always acting as the liason to translate user needs to us. When we are aware of user needs, it enables us to be proactive: to avoid that shortcut when building, or deal with that performance bottleneck early before it becomes a problem. We can also free the up the product manager to pursue broader goals such as product vision, market and competitive landscape analysis, etc.</p>

<p>Tomorrow, when you get to work, ask yourself that question. Do you know who your users are and how they use your product? How many degrees of separation would you have to navigate to find that answer? If you are not comfortable with the answer, maybe you can think of a way to change that.</p>

<p>Disclaimer: Thoughts expressed in the article are mine only, and does not represent the positions of current or past employers.</p>
]]></content>
  </entry>
  
</feed>
